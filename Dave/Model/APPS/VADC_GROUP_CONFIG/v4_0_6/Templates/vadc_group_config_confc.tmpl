package Model.APPS.VADC_GROUP_CONFIG.v4_0_6.Templates;

import Model.APPS.VADC_GROUP_CONFIG.v4_0_6.VADC_GROUP_CONFIG

out.print("""
/***********************************************************************************************************************
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2016-06-27:
 *     - Initial version for DAVEv4
 *
 * 2016-08-18:
 *     - Documentation update.<br>    
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "vadc_group_config.h"

""")
Integer MAX_NUM_CHANNELS = 8;
Integer MAX_NUM_RESULT_REG = 16;

Map input_class_selection = ["Group-Specific Class 0":"XMC_VADC_CHANNEL_CONV_GROUP_CLASS0",
	"Group-Specific Class 1":"XMC_VADC_CHANNEL_CONV_GROUP_CLASS1",
	"Global Class 0":"XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0",
	"Global Class 1":"XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS1"];

Map boundary_selection = ["Group-Specific Boundary 0":"XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0",
	"Group-Specific Boundary 1":"XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1",
	"Global Boundary 0":"XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND0",
	"Global Boundary 1":"XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND1"];

List channel_event_gen_array = ['XMC_VADC_CHANNEL_EVGEN_NEVER','XMC_VADC_CHANNEL_EVGEN_INBOUND','XMC_VADC_CHANNEL_EVGEN_OUTBOUND',
					'XMC_VADC_CHANNEL_EVGEN_ALWAYS']

List analog_reference_selection = ["XMC_VADC_CHANNEL_REF_INTREF","XMC_VADC_CHANNEL_REF_ALT_CH0"]

Map result_alignment = ["Right-Aligned": "XMC_VADC_RESULT_ALIGN_RIGHT,  /* Result alignment - Right Aligned*/",
	"Left-Aligned" :"XMC_VADC_RESULT_ALIGN_LEFT,   /* Result alignment - Left Aligned*/"]

Map rcr_dmm = ["Accumulate Values":"XMC_VADC_DMM_REDUCTION_MODE", "Apply Filter":"XMC_VADC_DMM_FILTERING_MODE", "Difference Mode":"XMC_VADC_DMM_DIFFERENCE_MODE"]

Map rcr_drctr = [
	'Data Reduction Disabled': 0 ,
	'Subtraction Mode': 0,
	'2 Result Values':1 ,
	'3 Result Values':2 ,
	'4 Result Values':3 ,
	'FIR filter: a=2, b=1, c=0' : 0 ,
	'FIR filter: a=1, b=2, c=0' : 1 ,
	'FIR filter: a=2, b=0, c=1' : 2 ,
	'FIR filter: a=1, b=1, c=1' : 3 ,
	'FIR filter: a=1, b=0, c=2' : 4 ,
	'FIR filter: a=3, b=1, c=0' : 5 ,
	'FIR filter: a=2, b=2, c=0' : 6 ,
	'FIR filter: a=1, b=3, c=0' : 7 ,
	'FIR filter: a=3, b=0, c=1' : 8 ,
	'FIR filter: a=2, b=1, c=1' : 9 ,
	'FIR filter: a=1, b=2, c=1' : 10 ,
	'FIR filter: a=2, b=0, c=2' : 11 ,
	'FIR filter: a=1, b=1, c=2' : 12 ,
	'FIR filter: a=1, b=0, c=3' : 13 ,
	'IIR filter: a=2, b=2' : 14 ,
	'IIR filter: a=3, B=4' : 15
	]

List StartMode        = ['XMC_VADC_STARTMODE_WFS','XMC_VADC_STARTMODE_CIR','XMC_VADC_STARTMODE_CNR']
List Trigger          = ['XMC_VADC_TRIGGER_EDGE_NONE','XMC_VADC_TRIGGER_EDGE_FALLING','XMC_VADC_TRIGGER_EDGE_RISING','XMC_VADC_TRIGGER_EDGE_ANY'];
List Gating           = ['XMC_VADC_GATEMODE_BLOCK','XMC_VADC_GATEMODE_IGNORE','XMC_VADC_GATEMODE_ACTIVEHIGH','XMC_VADC_GATEMODE_ACTIVELOW'];
List rs_priority	  = ['XMC_VADC_GROUP_RS_PRIORITY_0','XMC_VADC_GROUP_RS_PRIORITY_1','XMC_VADC_GROUP_RS_PRIORITY_2','XMC_VADC_GROUP_RS_PRIORITY_3']

List Gating_signal = ['XMC_VADC_REQ_GT_A','XMC_VADC_REQ_GT_B','XMC_VADC_REQ_GT_C','XMC_VADC_REQ_GT_D','XMC_VADC_REQ_GT_E','XMC_VADC_REQ_GT_F',
					  'XMC_VADC_REQ_GT_G','XMC_VADC_REQ_GT_H','XMC_VADC_REQ_GT_I','XMC_VADC_REQ_GT_J','XMC_VADC_REQ_GT_K','XMC_VADC_REQ_GT_L',
					  'XMC_VADC_REQ_GT_M','XMC_VADC_REQ_GT_N','XMC_VADC_REQ_GT_O','XMC_VADC_REQ_GT_P']

List trigger_signal = [ 'XMC_VADC_REQ_TR_A','XMC_VADC_REQ_TR_B','XMC_VADC_REQ_TR_C','XMC_VADC_REQ_TR_D','XMC_VADC_REQ_TR_E','XMC_VADC_REQ_TR_F',
						'XMC_VADC_REQ_TR_G','XMC_VADC_REQ_TR_H','XMC_VADC_REQ_TR_I','XMC_VADC_REQ_TR_J','XMC_VADC_REQ_TR_K','XMC_VADC_REQ_TR_L',
						'XMC_VADC_REQ_TR_M','XMC_VADC_REQ_TR_N','XMC_VADC_REQ_TR_O','XMC_VADC_REQ_TR_P']

List ServiceRequestLines = ['XMC_VADC_SR_GROUP_SR0','XMC_VADC_SR_GROUP_SR1','XMC_VADC_SR_GROUP_SR2','XMC_VADC_SR_GROUP_SR3',
	'XMC_VADC_SR_SHARED_SR0','XMC_VADC_SR_SHARED_SR1','XMC_VADC_SR_SHARED_SR2','XMC_VADC_SR_SHARED_SR3'];

List boundary_activation = ['XMC_VADC_CHANNEL_BOUNDARY_CONDITION_ABOVE_BAND', 'XMC_VADC_CHANNEL_BOUNDARY_CONDITION_BELOW_BAND']

List boundary_mode_control = ['XMC_VADC_CHANNEL_BOUNDARY_CONDITION_ABOVE_BAND', 'XMC_VADC_CHANNEL_BOUNDARY_CONDITION_BELOW_BAND']

List conv_mode = ['XMC_VADC_CONVMODE_12BIT','XMC_VADC_CONVMODE_10BIT','XMC_VADC_CONVMODE_8BIT','XMC_VADC_CONVMODE_FASTCOMPARE'];

List broken_wire = ['XMC_VADC_CHANNEL_BWDCH_VAGND','XMC_VADC_CHANNEL_BWDCH_VAREF'];

List emux_mode = ['XMC_VADC_GROUP_EMUXMODE_SWCTRL',
                  'XMC_VADC_GROUP_EMUXMODE_STEADYMODE',
                  'XMC_VADC_GROUP_EMUXMODE_SINGLEMODE',
                  'XMC_VADC_GROUP_EMUXMODE_SEQUENCEMODE']

List emux_coding = ['XMC_VADC_GROUP_EMUXCODE_BINARY',
                    'XMC_VADC_GROUP_EMUXCODE_GRAY']

String family = daveEnv.project.selectedDevice.deviceId.family;
String series = daveEnv.project.selectedDevice.deviceId.series;
String device = family + series

for (Object appIns : appInstancesList )
{
	instanceLabel = appIns.getInstanceLabel();
	if(device != 'XMC11')
	{
		String group_num = appIns.hwres_vadc_group_class0.getSolverUri()[6];
	}
	String channel_config_string ='';
	String sync_macros ="";
	String sync_code ="";
	Integer scan_channels_assel =0;
	Integer background_channels_brssel =0;
	String background_macro_string = ''
	String background_code_string = ''
	String background_init_string =''
	String scan_macro_string = ''
	String scan_code_string = ''
	String scan_init_string =''
	String queue_macro_string = ''
	String queue_code_string = ''
	String queue_init_string =''
	Integer total_queue_entires = 0;
	Integer num_of_channels = 0;
	Integer num_of_result_reg = 0;
	String channel_event_sr_config ='';
	String result_event_sr_config = '';
	Map channels_used = [:];
	String channel_bfl =''
	List queue_list = [appIns.gcombo_queue_req_src_entry0.value,appIns.gcombo_queue_req_src_entry1.value, appIns.gcombo_queue_req_src_entry2.value,
		appIns.gcombo_queue_req_src_entry3.value,appIns.gcombo_queue_req_src_entry4.value,appIns.gcombo_queue_req_src_entry5.value,
		appIns.gcombo_queue_req_src_entry6.value,appIns.gcombo_queue_req_src_entry7.value]
	
	List channel_hwres_list = [appIns.hwres_vadc_group_ch0,appIns.hwres_vadc_group_ch1, appIns.hwres_vadc_group_ch2,
		appIns.hwres_vadc_group_ch3,appIns.hwres_vadc_group_ch4,appIns.hwres_vadc_group_ch5,
		appIns.hwres_vadc_group_ch6,appIns.hwres_vadc_group_ch7]
	
	List scan_list = [appIns.gcheck_scan_req_src_ch0.value,appIns.gcheck_scan_req_src_ch1.value, appIns.gcheck_scan_req_src_ch2.value,
		appIns.gcheck_scan_req_src_ch3.value,appIns.gcheck_scan_req_src_ch4.value,appIns.gcheck_scan_req_src_ch5.value,
		appIns.gcheck_scan_req_src_ch6.value,appIns.gcheck_scan_req_src_ch7.value]
	
	List background_list = [appIns.gcheck_bkgnd_req_src_ch0.value,appIns.gcheck_bkgnd_req_src_ch1.value, appIns.gcheck_bkgnd_req_src_ch2.value,
		appIns.gcheck_bkgnd_req_src_ch3.value,appIns.gcheck_bkgnd_req_src_ch4.value,appIns.gcheck_bkgnd_req_src_ch5.value,
		appIns.gcheck_bkgnd_req_src_ch6.value,appIns.gcheck_bkgnd_req_src_ch7.value]
	
	
/****************************************************************************************************************************************************/
	out.println("""
/***********************************************************************************************************************
 * VADC_GROUP_CONFIG instance ${instanceLabel} configuration
 **********************************************************************************************************************/""");
String boundary_value_set = '';
String boundary_value_macros = '';
String channel_init_code = ''
if(device != 'XMC11')
{
	for(i=0;i<MAX_NUM_CHANNELS;i++)
	{
		if(queue_list[7-i] != "None")
		{
//			channels_used.add(queue_list[i].split(" ")[1])
			Integer channel_number = queue_list[7-i].split(" ")[1].toInteger()			
			channels_used.put(channel_number,channel_hwres_list[channel_number])
			total_queue_entires++;
		}
		if(scan_list[i] == true)
		{
			channels_used.put(i,channel_hwres_list[i])
			scan_channels_assel |= 1 << i;
		}
		if(background_list[i] == true)
		{
			channels_used.put(i,channel_hwres_list[i])
			background_channels_brssel |= 1 << i;
		}
		if(appIns.rarray_channels_consumed[i].value == true)
		{
			channels_used.put(i,channel_hwres_list[i])
		}
	}
//	rArraygindexgroup_channels_configuration[channels_used.keys()[0].gcombo_ch_input_class.value]
//	channels_used.sort{it.value}
	
	/* For boundary settings*/
	if(appIns.gcheck_en_bfl_0.value|| appIns.gcheck_en_bfl_1.value|| appIns.gcheck_en_bfl_2.value|| appIns.gcheck_en_bfl_3.value)
	{
		if(device == "XMC45")
		{
			channel_bfl = """
  .boundary_flag_output_ch0 = (uint32_t)${appIns.gcheck_en_bfl_0.value},
  .boundary_flag_output_ch1 = (uint32_t)${appIns.gcheck_en_bfl_1.value},
  .boundary_flag_output_ch2 = (uint32_t)${appIns.gcheck_en_bfl_2.value},
  .boundary_flag_output_ch3 = (uint32_t)${appIns.gcheck_en_bfl_3.value},
"""
		}
		else
		{
			channel_bfl = """
  .invert_boundary_flag_ch0 = (uint32_t)${appIns.gcheck_inv_bfl_0.value},
  .invert_boundary_flag_ch1 = (uint32_t)${appIns.gcheck_inv_bfl_1.value},
  .invert_boundary_flag_ch2 = (uint32_t)${appIns.gcheck_inv_bfl_2.value},
  .invert_boundary_flag_ch3 = (uint32_t)${appIns.gcheck_inv_bfl_3.value},
  .flag_output_condition_ch0 = (uint32_t)${boundary_activation[appIns.gcombo_bfa_0.options.indexOf(appIns.gcombo_bfa_0.value)]},
  .flag_output_condition_ch1 = (uint32_t)${boundary_activation[appIns.gcombo_bfa_1.options.indexOf(appIns.gcombo_bfa_1.value)]},
  .flag_output_condition_ch2 = (uint32_t)${boundary_activation[appIns.gcombo_bfa_2.options.indexOf(appIns.gcombo_bfa_2.value)]},
  .flag_output_condition_ch3 = (uint32_t)${boundary_activation[appIns.gcombo_bfa_3.options.indexOf(appIns.gcombo_bfa_3.value)]},
"""
		}
	}
	 
	for( i in channels_used)
	{
		iclass_selection = input_class_selection[appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_input_class.value] // XMC_VADC_CHANNEL_CONV_
		upper_boundary_select = boundary_selection[appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_upper_boundary.value]
		lower_boundary_select = boundary_selection[appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_lower_boundary.value]
		event_gen_criteria = channel_event_gen_array[appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_event_mode.options.indexOf(appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_event_mode.value)]
		sync_conversion = appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcheck_ch_sync.value
		reference_selection = analog_reference_selection[(appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcheck_ch_reference_input_selection.value)?1:0]
		result_alignment_channel_config = result_alignment[appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_result_position.value]
		result_reg_num = appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_result_register.value.split("GxRES")[-1]
	
		/*For alias configurations only*/
		if((i.getKey() == 0 || i.getKey() == 1) && (appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_alias.value != "None"))
		{
			alias_channel_number = "(int8_t) XMC_VADC_CHANNEL_ALIAS_CH"+appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_alias.value.split(" ")[-1].toString()
		}
		else
		{
			alias_channel_number = "(int8_t) XMC_VADC_CHANNEL_ALIAS_DISABLED,   /* ALIAS is Disabled*/";
		}
		
		if( event_gen_criteria != 'XMC_VADC_CHANNEL_EVGEN_NEVER')
		{
			channel_event_sr_config += """/* Channel event node pointer configuration for Channel-${i.getKey()}*/
  XMC_VADC_GROUP_ChannelSetEventInterruptNode(${instanceLabel}_GROUP_PTR, ${i.getKey()}, (XMC_VADC_SR_t) ${ServiceRequestLines[i.getValue().getRegValue("","gcevnp0_cevnp").toInteger()]});"""
		}
	
		num_of_channels++;
		channel_config_string += """
  {
    .ch_num = (uint8_t) ${i.getKey()},
    .ch_handle = &${instanceLabel}_channel_${i.getKey()}_ch_config
  },"""
	
		out.print("""
/********************************* {channel_name} ADC Channel configuration structure ********************************/
static const XMC_VADC_CHANNEL_CONFIG_t  ${instanceLabel}_channel_${i.getKey()}_ch_config =
{
  .input_class                = (uint32_t) ${iclass_selection},
  .lower_boundary_select      = (uint32_t) ${lower_boundary_select},
  .upper_boundary_select      = (uint32_t) ${upper_boundary_select},
  .event_gen_criteria         = (uint32_t) ${event_gen_criteria},
  .sync_conversion            = (uint32_t) ${sync_conversion},                            /* Sync feature disabled*/
  .alternate_reference        = (uint32_t) ${reference_selection},
  .result_reg_number          = (uint32_t) ${result_reg_num},                           /* GxRES[{result_reg_num}] selected */
  .use_global_result          = (uint32_t) ${appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_result_target_bkgnd_src.options.indexOf(appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_result_target_bkgnd_src.value)},
  .result_alignment           = (uint32_t) ${result_alignment_channel_config}
  .broken_wire_detect_channel = (uint32_t) ${broken_wire[appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_broken_wire_detection_channel.options.indexOf(appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcombo_ch_broken_wire_detection_channel.value)]}, /* No Broken wire mode select*/
  .broken_wire_detect         = (uint32_t) ${appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcheck_ch_broken_wire_detection_enable.value},          /* Broken wire detection*/${i.getKey()<=3?channel_bfl:''}
  .channel_priority           = (bool) ${appIns.rArraygindexgroup_channels_configuration[i.getKey()].gcheck_ch_ass.value},                        /* Highest Priority: 1 selected*/
  .alias_channel              = ${alias_channel_number}
};

""")
	}

	
	if(channels_used != [:])
	{
		channel_init_code = """
  /* CHANNEL init*/
  index = (int)${instanceLabel}_NUM_OF_CHANNELS;
  while (index >= 0)
  {
    XMC_VADC_GROUP_ChannelInit(${instanceLabel}_GROUP_PTR,
                               (uint32_t)${instanceLabel}_channel_config[index].ch_num,
                               ${instanceLabel}_channel_config[index].ch_handle);
    index--;
  }"""
	
		out.print("""
static const VADC_GROUP_CONFIG_CHANNEL_t ${instanceLabel}_channel_config[] =
{${channel_config_string}
};
/*********************************************************************************************************************/
""");
	}
/****************************************************************************************************************************************************/

	if ((appIns.ginteger_boundary0.value != 0) || (appIns.ginteger_boundary1.value != 0))
	{
		boundary_value_macros = """\n#define ${instanceLabel}_LOWER_BOUND_VALUE (${appIns.ginteger_boundary0.value}U)
#define ${instanceLabel}_UPPER_BOUND_VALUE (${appIns.ginteger_boundary1.value}U)"""
		boundary_value_set ="""\n  XMC_VADC_GROUP_SetBoundaries(${instanceLabel}_GROUP_PTR,
                               ${instanceLabel}_LOWER_BOUND_VALUE, 
                               ${instanceLabel}_UPPER_BOUND_VALUE);"""
	}

} //if(device != 'XMC11')
/****************************************************************************************************************************************************/
String result_config_string = ''
String result_reg_priority = '';
String result_reg_priority_macro = '';
String result_init_code = '';
if(device != 'XMC11')
{
	for( i in 0..MAX_NUM_RESULT_REG-1)
	{
		String data_reduction_control = '0'
		String channel_name = '';
		Integer channel_no = -1
		result_uri = appIns.rarray_hwres_vadc_group_config_result_registers[i].getSolverUri()
		if( result_uri == null)
			continue;
		post_processing_mode = rcr_dmm[appIns.rArraygindexgroup_result_registers_configuration[i].gcombo_result_register_data_modification_mode.value]
		if(post_processing_mode != "XMC_VADC_DMM_DIFFERENCE_MODE")
		{
			data_reduction_control = rcr_drctr[appIns.rArraygindexgroup_result_registers_configuration[i].gcombo_result_register_drctr.value]
		}
		wait_for_read_mode = appIns.rArraygindexgroup_result_registers_configuration[i].gcheck_result_register_wait_for_read_enable.value
		part_of_fifo = appIns.rArraygindexgroup_result_registers_configuration[i].gcheck_result_register_fifo_mode_enable.value
		event_gen_enable = appIns.rArraygindexgroup_result_registers_configuration[i].gcheck_result_register_event_enable.value
		
		for(ch_no in 0..MAX_NUM_CHANNELS-1)
		{
			 channel_no = (appIns.rArraygindexgroup_channels_configuration[ch_no].gcombo_result_register.value.split("GxRES")[-1].toInteger()== i && appIns.rarray_channels_consumed[ch_no].value) ? ch_no:channel_no
		}
		if( channel_no != -1 )
		{
			channel_name = "Channel_${channel_no}"
		}
		
		if( event_gen_enable)
		{
			result_event_sr_config += """/* Result event node pointer configuration for Result Register-${i}*/
  XMC_VADC_GROUP_SetResultInterruptNode(${instanceLabel}_GROUP_PTR, (uint32_t)${i}, (XMC_VADC_SR_t)${ServiceRequestLines[appIns.rarray_hwres_vadc_group_config_result_registers[i].getRegValue("","grevnp_revnp").toInteger()]});"""
		}
	
		num_of_result_reg++;
		result_config_string += """
  {
    .res_reg_num = (uint8_t) ${i},
    .res_handle = &${instanceLabel}_result${i}_config
  },"""
			out.println("""
/* ${channel_name} Result configuration structure*/
static const XMC_VADC_RESULT_CONFIG_t ${instanceLabel}_result${i}_config =
{
  .data_reduction_control  = (uint32_t) ${data_reduction_control},
  .post_processing_mode    = (uint32_t) ${post_processing_mode},
  .wait_for_read_mode      = (uint32_t) ${wait_for_read_mode},
  .part_of_fifo            = (uint32_t) ${part_of_fifo} ,
  .event_gen_enable        = ${event_gen_enable}
};
""")
	}

	
	if(num_of_result_reg !=0)
	{
		result_init_code = """
  /* result init */
  index = (int)${instanceLabel}_NUM_OF_RESULT_REGISTERS;
  while (index >= 0)
  {
    XMC_VADC_GROUP_ResultInit(${instanceLabel}_GROUP_PTR,
                              (uint32_t)${instanceLabel}_result_config[index].res_reg_num,
                              ${instanceLabel}_result_config[index].res_handle);
    index--;
  }
"""
		out.print("""
static const VADC_GROUP_CONFIG_RESULT_REGISTER_t ${instanceLabel}_result_config[] =
{${result_config_string}
};
/*********************************************************************************************************************/
""");
}

	if(family == "XMC1" && device != "XMC11")
	{
		Integer reg_mask =0;
		for (reg_num in 0..15)
		{
			reg_mask |= (((appIns.rArraygindexgroup_result_registers_configuration[reg_num].gcheck_result_reg_ass.value)?1:0).leftShift(reg_num))
		}
		if(reg_mask!=0)
		{
			result_reg_priority_macro = """\n#define ${instanceLabel}_RESULT_REG_PRI_MASK (${reg_mask}U)"""
			result_reg_priority = """XMC_VADC_GROUP_SetResultRegPriority(${instanceLabel}_GROUP_PTR,${instanceLabel}_RESULT_REG_PRI_MASK);"""
		}
	}
} //if(device != 'XMC11')

/****************************************************************************************************************************************************/
String queue_entries_string = ''
if(total_queue_entires != 0)
{
	for( i in 0..MAX_NUM_CHANNELS-1)
	{
		int index = i
		local_channel_num = appIns."gcombo_queue_req_src_entry${i}".value
		if(local_channel_num == "None")
			continue
		local_channel_num = local_channel_num.split(" ")[-1]
		refill_needed = appIns."gcheck_queue_req_src_entry${i}_refill".value
		external_trigger = appIns."gcheck_queue_req_src_entry${i}_event_enable".value
		generate_interrupt = appIns."gcheck_queue_req_src_entry${i}_trigger_enable".value
		
	//	queue_entries_string += "\n  &${instanceLabel}_queue_entry_${7-i},"
		//static const XMC_VADC_QUEUE_ENTRY_t ${instanceLabel}_queue_entry_${7-i} =
		/*****************************Queue Entry Position ${7-i}***************************************/
		queue_entries_string += """
    { /* Queue Entry Position ${7-i} */
      .channel_num        = (uint8_t) ${local_channel_num},
      .refill_needed      = (bool) ${refill_needed},
      .generate_interrupt = (bool) ${generate_interrupt},
      .external_trigger   = (bool) ${external_trigger},
    },
"""
	}

	out.print("""
static const XMC_VADC_QUEUE_ENTRY_t ${instanceLabel}_queue_entries[] =
{${queue_entries_string}
};
/*********************************************************************************************************************/
""");
}

/****************************************************************************************************************************************************/
/* For sync related configurations*/
sync_group_num = appIns.gcombo_synctr_stsel.options.indexOf(appIns.gcombo_synctr_stsel.value).toInteger() - 1;
if(sync_group_num  != -1)
{
	sync_macros ="""
/* Applicable only for sync operation.*/
#define ${instanceLabel}_MASTER_GROUP_PTR ((XMC_VADC_GROUP_t*)(void*) VADC_G${sync_group_num})
#define ${instanceLabel}_MASTER_GROUP_NUM (${sync_group_num}U)
"""
		String eval_mask;
	eval_mask = (appIns.hwres_vadc_group_sync.getRegValue("","gsynctr_evalr1")?"VADC_G_SYNCTR_EVALR1_Msk":"")
	eval_mask += (appIns.hwres_vadc_group_sync.getRegValue("","gsynctr_evalr2")?(eval_mask!=""?"| ":"" )+"VADC_G_SYNCTR_EVALR2_Msk":"")
	eval_mask += (appIns.hwres_vadc_group_sync.getRegValue("","gsynctr_evalr3")?(eval_mask!=""?"| ":"" )+"VADC_G_SYNCTR_EVALR3_Msk":"")
	if(eval_mask == "")
	{
		eval_mask += "0U"
		sync_macros += "#warning \" Configuration of the EVAL signals in the HW signal connectivity not done\"\n"
	} 
	sync_macros += "#define ${instanceLabel}_ALL_EVAL_MASK (${eval_mask})"
	
	sync_code = """/* Sync related init*/
/*  power off all the groups participating in sync. */
  XMC_VADC_GROUP_SetPowerMode(${instanceLabel}_GROUP_PTR,
                              (XMC_VADC_GROUP_POWERMODE_t )XMC_VADC_GROUP_POWERMODE_OFF);  

  XMC_VADC_GROUP_SetPowerMode(${instanceLabel}_MASTER_GROUP_PTR, 
                              (XMC_VADC_GROUP_POWERMODE_t) XMC_VADC_GROUP_POWERMODE_OFF); 

  XMC_VADC_GROUP_SetSyncSlave(${instanceLabel}_GROUP_PTR, 
                              ${instanceLabel}_MASTER_GROUP_NUM, 
                              ${instanceLabel}_GROUP_NUM);

  XMC_VADC_GROUP_CheckSlaveReadiness(${instanceLabel}_MASTER_GROUP_PTR, ${instanceLabel}_GROUP_NUM);

  /*Ensure the ready signals of all the slaves and the master are connected to EACH OTHER. */
  XMC_VADC_GROUP_SetSyncReadySignal(${instanceLabel}_GROUP_PTR, ${instanceLabel}_ALL_EVAL_MASK);

  XMC_VADC_GROUP_SetPowerMode(${instanceLabel}_MASTER_GROUP_PTR, 
                              (XMC_VADC_GROUP_POWERMODE_t) XMC_VADC_GROUP_POWERMODE_NORMAL);
"""
}

/****************************************************************************************************************************************************/
if(device == 'XMC11')
{
	for ( i in 0..7)
	{
		if(background_list[i] == true)
		{
			channels_used.put(i,channel_hwres_list[i])
			background_channels_brssel |= 1 << i;
		}
	}
}
if(background_channels_brssel !=0 )
{
	background_macro_string = "#define ${instanceLabel}_BACKGROUD_SCAN_CHANNELS (${background_channels_brssel}U)"
	if(device != 'XMC11')
	{
		background_init_string = """\n  ${!appIns.gcheck_arbitration_slot2_enable.value?"XMC_VADC_GROUP_BackgroundDisableArbitrationSlot("+instanceLabel+"_GROUP_PTR);":""}
"""
	}
	background_code_string = """/* Insert channels in to the background request sources*/
  XMC_VADC_GLOBAL_BackgndAddMultipleChannels(${instanceLabel}_MODULE_PTR,
                                             ${instanceLabel}_GROUP_NUM,
                                             ${instanceLabel}_BACKGROUD_SCAN_CHANNELS);"""

}
/****************************************************************************************************************************************************/
String src_specific_result_reg = ''
if(scan_channels_assel !=0 )
{
	scan_macro_string = "#define ${instanceLabel}_SCAN_CHANNELS (${scan_channels_assel}U)"
	scan_init_string = """\n  XMC_VADC_GROUP_ScanInit(${instanceLabel}_GROUP_PTR, &${instanceLabel}_scan_config);
  XMC_VADC_GROUP_ScanSetGatingMode(${instanceLabel}_GROUP_PTR, (XMC_VADC_GATEMODE_t) ${Gating[appIns.gcombo_scan_req_src_gate_enable.options.indexOf(appIns.gcombo_scan_req_src_gate_enable.value)]});
  XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(${instanceLabel}_GROUP_PTR, (XMC_VADC_SR_t) ${ServiceRequestLines[appIns.hwres_vadc_group_scan.getRegValue("","gsevnp_sev1np").toInteger()]});
  ${!appIns.gcheck_arbitration_slot1_enable.value?"XMC_VADC_GROUP_ScanDisableArbitrationSlot("+instanceLabel+"_GROUP_PTR);":""}"""
	
	scan_code_string = """/* Insert channels in to the scan request sources*/
  XMC_VADC_GROUP_ScanAddMultipleChannels(${instanceLabel}_GROUP_PTR, ${instanceLabel}_SCAN_CHANNELS); """
	
	if(device != "XMC45")
	{
		src_specific_result_reg = """.src_specific_result_reg = (uint32_t)${(appIns.gcombo_scan_req_src_res_reg.value == "No Specific Register")? "0":appIns.gcombo_scan_req_src_res_reg.value.split("GxRES")[-1]}"""
	}
	
	out.println("""
/**********************SCAN Request source configuration*********************************/
static const XMC_VADC_SCAN_CONFIG_t ${instanceLabel}_scan_config = {
  .conv_start_mode   = (uint32_t) ${StartMode[appIns.gcombo_arbitration_slot1_conversion_start_mode.options.indexOf(appIns.gcombo_arbitration_slot1_conversion_start_mode.value)]},     /* Conversion start mode WFS/CIR/CNR*/
  .req_src_priority  = (uint32_t) ${rs_priority[appIns.gcombo_arbitration_slot1_priority.options.indexOf(appIns.gcombo_arbitration_slot1_priority.value)]}, /*The scan request source priority */
  .trigger_signal    = (uint32_t) ${String temp = appIns.hwres_vadc_group_scan.getRegValue("","gasctrl_xtsel"); if(temp !=null){ trigger_signal[temp.toInteger()] } else { trigger_signal[0]} },       /*If trigger needed the signal input*/
  .trigger_edge      = (uint32_t) ${Trigger[appIns.gcombo_scan_req_src_trigger_mode.options.indexOf(appIns.gcombo_scan_req_src_trigger_mode.value)]},   /*Trigger edge needed if trigger enabled*/
  .gate_signal       = (uint32_t) ${String temp = appIns.hwres_vadc_group_scan.getRegValue("","gasctrl_gtsel"); if(temp !=null){ Gating_signal[temp.toInteger()] } else { Gating_signal[0]} },            /*If gating needed the signal input*/
  .timer_mode        = (uint32_t) ${appIns.gcheck_scan_req_src_enable_timer_mode.value},                      /* Disabled equidistant sampling*/
  .external_trigger  = (uint32_t) ${appIns.gcheck_scan_req_src_enable_trigger.value},                         /*External trigger Enabled/Disabled*/
  .req_src_interrupt = (uint32_t) ${appIns.gcheck_scan_req_src_enable_interrupt.value},                      /*Request source event Enabled/disabled*/
  .enable_auto_scan  = (uint32_t) ${appIns.gcheck_scan_req_src_autoscan_enabled.value},  /*Autoscan enabled/disabled */
  .load_mode         = (uint32_t) XMC_VADC_SCAN_LOAD_COMBINE,   /*Response from SCAN when a Load event occours.*/
  $src_specific_result_reg
};
/*********************************************************************************************************************/
""");
}
/****************************************************************************************************************************************************/
src_specific_result_reg = ''
if(total_queue_entires != 0)
{
	queue_macro_string = "#define ${instanceLabel}_TOTAL_QUEUE_ENTIRES (${total_queue_entires -1}U)"
	queue_init_string = """XMC_VADC_GROUP_QueueInit(${instanceLabel}_GROUP_PTR, &${instanceLabel}_queue_config);
  XMC_VADC_GROUP_QueueSetGatingMode(${instanceLabel}_GROUP_PTR, (XMC_VADC_GATEMODE_t) ${Gating[appIns.gcombo_queue_req_src_gate_enable.options.indexOf(appIns.gcombo_queue_req_src_gate_enable.value)]});
  XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode(${instanceLabel}_GROUP_PTR, (XMC_VADC_SR_t) ${ServiceRequestLines[appIns.hwres_vadc_group_queue.getRegValue("","gsevnp_sev0np").toInteger()]});
  ${!appIns.gcheck_arbitration_slot0_enable.value?"XMC_VADC_GROUP_QueueDisableArbitrationSlot("+instanceLabel+"_GROUP_PTR);":""}"""
	
	queue_code_string = """
  /* Insert channels in to the background request sources*/
  index = (int)${instanceLabel}_TOTAL_QUEUE_ENTIRES;
  while (index >= 0)
  {
    XMC_VADC_GROUP_QueueInsertChannel(${instanceLabel}_GROUP_PTR, ${instanceLabel}_queue_entries[index--]);
  }
"""
	if(device != "XMC45")
	{
		src_specific_result_reg = """.src_specific_result_reg = (uint32_t) ${(appIns.gcombo_queue_req_src_res_reg.value == "No Specific Register")? "0":appIns.gcombo_queue_req_src_res_reg.value.split("GxRES")[-1]}"""
	}
	
	
out.println("""
/**********************QUEUE Request source configuration*********************************/
static const XMC_VADC_QUEUE_CONFIG_t ${instanceLabel}_queue_config = {
  .conv_start_mode   = (uint32_t) ${StartMode[appIns.gcombo_arbitration_slot0_conversion_start_mode.options.indexOf(appIns.gcombo_arbitration_slot0_conversion_start_mode.value)]},  /* Conversion start mode WFS/CIR/CNR*/
  .req_src_priority  = (uint32_t) ${rs_priority[appIns.gcombo_arbitration_slot0_priority.options.indexOf(appIns.gcombo_arbitration_slot0_priority.value)]}, /*The queue request source priority */
  .trigger_signal    = (uint32_t) ${String temp = appIns.hwres_vadc_group_queue.getRegValue("","gqctrl0_xtsel"); if(temp !=null){ trigger_signal[temp.toInteger()] } else { trigger_signal[0]} },       /*If trigger needed the signal input*/
  .trigger_edge      = (uint32_t) ${Trigger[appIns.gcombo_queue_req_src_trigger_mode.options.indexOf(appIns.gcombo_queue_req_src_trigger_mode.value)]},   /*Trigger edge needed if trigger enabled*/
  .gate_signal       = (uint32_t) ${String temp = appIns.hwres_vadc_group_queue.getRegValue("","gqctrl0_gtsel"); if(temp !=null){ Gating_signal[temp.toInteger()] } else { Gating_signal[0]} },            /*If gating needed the signal input*/
  .timer_mode        = (uint32_t) ${appIns.gcheck_queue_req_src_enable_timer_mode.value},                            /* Equidistant sampling*/
  .external_trigger  = (uint32_t) ${appIns.gcheck_queue_req_src_enable_trigger.value},                    /*External trigger Enabled/Disabled*/
  $src_specific_result_reg
};
/*********************************************************************************************************************/
""")

}
/****************************************************************************************************************************************************/
String iclass_cfg_string =''
String iclass_init_string =''

String iclass0_cfg_string = """
static const XMC_VADC_GROUP_CLASS_t ${instanceLabel}_iclass_0 = 
{
  .sample_time_std_conv        = (uint32_t) ${appIns.ginteger_grpic0_std_conv_sample_phase_length.value}, 
  .conversion_mode_standard    = ${conv_mode[appIns.gcombo_grpic0_std_conv_conversion_mode.options.indexOf(appIns.gcombo_grpic0_std_conv_conversion_mode.value)]}, 
  .sampling_phase_emux_channel = (uint32_t) ${appIns.ginteger_grpic0_emux_conv_sample_phase_length.value},
  .conversion_mode_emux        = ${conv_mode[appIns.gcombo_grpic0_emux_conv_conversion_mode.options.indexOf(appIns.gcombo_grpic0_emux_conv_conversion_mode.value)]}
};
"""
String iclass0_init_string = """
  XMC_VADC_GROUP_InputClassInit(${instanceLabel}_GROUP_PTR, 
                                ${instanceLabel}_iclass_0, 
                                XMC_VADC_GROUP_CONV_STD, 
                                ${instanceLabel}_ICLASS_0);
  XMC_VADC_GROUP_InputClassInit(${instanceLabel}_GROUP_PTR, 
                                ${instanceLabel}_iclass_0, 
                                XMC_VADC_GROUP_CONV_EMUX, 
                                ${instanceLabel}_ICLASS_0);
"""
		
String iclass1_cfg_string = """
static const XMC_VADC_GROUP_CLASS_t ${instanceLabel}_iclass_1 = 
{
  .sample_time_std_conv        = (uint32_t) ${appIns.ginteger_grpic1_std_conv_sample_phase_length.value}, 
  .conversion_mode_standard    = ${conv_mode[appIns.gcombo_grpic1_std_conv_conversion_mode.options.indexOf(appIns.gcombo_grpic1_std_conv_conversion_mode.value)]}, 
  .sampling_phase_emux_channel = (uint32_t) ${appIns.ginteger_grpic1_emux_conv_sample_phase_length.value},
  .conversion_mode_emux        = ${conv_mode[appIns.gcombo_grpic1_emux_conv_conversion_mode.options.indexOf(appIns.gcombo_grpic1_emux_conv_conversion_mode.value)]}
};
"""

String iclass1_init_string = """
  XMC_VADC_GROUP_InputClassInit(${instanceLabel}_GROUP_PTR, 
                                ${instanceLabel}_iclass_1, 
                                (XMC_VADC_GROUP_CONV_t) XMC_VADC_GROUP_CONV_STD, 
                                ${instanceLabel}_ICLASS_1);
  XMC_VADC_GROUP_InputClassInit(${instanceLabel}_GROUP_PTR, 
                                ${instanceLabel}_iclass_1, 
                                (XMC_VADC_GROUP_CONV_t) XMC_VADC_GROUP_CONV_EMUX, 
                                ${instanceLabel}_ICLASS_1);
"""

if((appIns.ginteger_grpic0_std_conv_sample_phase_length.value != 0) ||
	(appIns.gcombo_grpic0_std_conv_conversion_mode.options.indexOf(appIns.gcombo_grpic0_std_conv_conversion_mode.value) != 0 ) ||
	(appIns.ginteger_grpic0_emux_conv_sample_phase_length.value) ||
	(appIns.gcombo_grpic0_emux_conv_conversion_mode.options.indexOf(appIns.gcombo_grpic0_emux_conv_conversion_mode.value) != 0))
{
	iclass_cfg_string += iclass0_cfg_string
	iclass_init_string += iclass0_init_string
}
if((appIns.ginteger_grpic1_std_conv_sample_phase_length.value != 0) ||
	(appIns.gcombo_grpic1_std_conv_conversion_mode.options.indexOf(appIns.gcombo_grpic1_std_conv_conversion_mode.value) != 0 ) ||
	(appIns.ginteger_grpic1_emux_conv_sample_phase_length.value) ||
	(appIns.gcombo_grpic1_emux_conv_conversion_mode.options.indexOf(appIns.gcombo_grpic1_emux_conv_conversion_mode.value) != 0))
{
	iclass_cfg_string += iclass1_cfg_string
	iclass_init_string += iclass1_init_string
}

String emux_cfg_string = ""
String emux_init_string = ""

if ((appIns.gcheck_extmul_ch0.value || appIns.gcheck_extmul_ch1.value || appIns.gcheck_extmul_ch2.value || appIns.gcheck_extmul_ch3.value ||
	 appIns.gcheck_extmul_ch4.value || appIns.gcheck_extmul_ch5.value || appIns.gcheck_extmul_ch6.value || appIns.gcheck_extmul_ch7.value) && appIns.gcombo_extmul_mode.value != "Software Control")
{
  emux_cfg_string = """
static const XMC_VADC_GROUP_EMUXCFG_t ${instanceLabel}_emux_cfg = 
{
  .starting_external_channel = ${appIns.ginteger_extmul_start_selection.value},
#if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
  .connected_channel = ${(appIns.gcheck_extmul_ch0.value ? 1 : 0) | (appIns.gcheck_extmul_ch1.value ? 2 : 0) | (appIns.gcheck_extmul_ch2.value ? 4 : 0) | (appIns.gcheck_extmul_ch3.value ? 8 : 0) |
                         (appIns.gcheck_extmul_ch4.value ? 16 : 0) | (appIns.gcheck_extmul_ch5.value ? 32 : 0) | (appIns.gcheck_extmul_ch6.value ? 64 : 0) | (appIns.gcheck_extmul_ch7.value ? 128 : 0)},
#else
  .connected_channel = ${(appIns.gcheck_extmul_ch0.value ? 0 : 0) | (appIns.gcheck_extmul_ch1.value ? 1 : 0) | (appIns.gcheck_extmul_ch2.value ? 2 : 0) | (appIns.gcheck_extmul_ch3.value ? 3 : 0) |
                         (appIns.gcheck_extmul_ch4.value ? 4 : 0) | (appIns.gcheck_extmul_ch5.value ? 5 : 0) | (appIns.gcheck_extmul_ch6.value ? 6 : 0) | (appIns.gcheck_extmul_ch7.value ? 7 : 0)},
#endif
  .emux_mode = ${emux_mode[appIns.gcombo_extmul_mode.options.indexOf(appIns.gcombo_extmul_mode.value)]},
  .emux_coding = ${emux_coding[appIns.gcombo_extmul_coding_scheme.options.indexOf(appIns.gcombo_extmul_coding_scheme.value)]},
  .stce_usage = ${appIns.gcombo_extmul_sample_time_control.options.indexOf(appIns.gcombo_extmul_sample_time_control.value)},
#if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
  .emux_channel_select_style = 1
#endif
};
  """
  
  emux_init_string = """
  XMC_VADC_GROUP_ExternalMuxControlInit(${instanceLabel}_GROUP_PTR, ${instanceLabel}_emux_cfg);
  """
}

out.println("""
/**********************Group Input class configuration*********************************/
${iclass_cfg_string}
/*********************************************************************************************************************/

/**********************Group EMUX configuration*********************************/
${emux_cfg_string}
/*********************************************************************************************************************/

""")

/****************************************************************************************************************************************************/

/****************************************************************************************************************************************************/
/****************************************************************************************************************************************************/
/****************************************************************************************************************************************************/
	/* Code for the VADC_GROUP_CONFIG APP */
	out.print("""
/***********************************************************************************************************************
 * VADC_GROUP_CONFIG instance ${instanceLabel} code
 **********************************************************************************************************************/
#define ${instanceLabel}_NUM_OF_CHANNELS (${num_of_channels -1}U)
${(device !='XMC11')?'#define '+instanceLabel+'_NUM_OF_RESULT_REGISTERS ('+(num_of_result_reg -1)+'U)':''}
#define ${instanceLabel}_ICLASS_0 (0U)
#define ${instanceLabel}_ICLASS_1 (1U)
${queue_macro_string}
${scan_macro_string}
${background_macro_string}
${sync_macros}${result_reg_priority_macro}${boundary_value_macros}
/**********************************************************************************************************************/
VADC_GROUP_CONFIG_STATUS_t ${instanceLabel}_Init(void)
{
  VADC_GROUP_CONFIG_STATUS_t status;
  int index;

  status  = (VADC_GROUP_CONFIG_STATUS_t) VADC_GLOBAL_CONFIG_Init(&VADC_GLOBAL_CONFIG_0);

  /* Request source initializations*/
  ${queue_init_string} ${scan_init_string} ${background_init_string}
  ${iclass_init_string}
  ${emux_init_string}
  ${sync_code}
  ${boundary_value_set}
  ${channel_init_code}
  ${result_init_code}

  ${result_reg_priority}
  ${channel_event_sr_config}
  ${result_event_sr_config}

  ${background_code_string}
  ${scan_code_string}
  ${queue_code_string}${((channel_init_code == '') && (result_init_code == '') && (queue_code_string == ''))?"\nXMC_UNUSED_ARG(index);":""}

  return(status);
}
""")
if(device != "XMC11")
{	
	out.println("""
/**********************************************************************************************************************/
const VADC_GROUP_CONFIG_t ${instanceLabel} =
{
  .init_func = (${instanceLabel}_Init),
  .group_ptr = ${instanceLabel}_GROUP_PTR,
  .module_ptr = ${instanceLabel}_MODULE_PTR
};
/**********************************************************************************************************************/""")
}
else
{
	out.println("""
/**********************************************************************************************************************/
const VADC_GROUP_CONFIG_t ${instanceLabel} =
{
  .init_func = (${instanceLabel}_Init),
  .module_ptr = ${instanceLabel}_MODULE_PTR
};
/**********************************************************************************************************************/""")
}
	
	
} /*for (Object appIns : appInstancesList )*/
