/************************************************************************************************************************************
 * Title : XMC 4500 ADC Intro                                                                                                       *
 *                                                                                                                                  *
 * Author : Gert van Biljon                                                                                                         *
 *                                                                                                                                  *
 * EMail : gertvb@gmail.com                                                                                                         *
 ***********************************************************************************************************************************/

/************************************************************************************************************************************
 * What am I : Demo project to illustrate the continuous transfer of VADC values with DMA in Infineon's DAVE 4.4.2 on an            *
 *             XMC4500 Relax Lite                                                                                                   *
 *                                                                                                                                  *
 * DAVE 4.4.2 reconfigure : To reduce the size of the archive I had to delete some of the files Generated by DAVE, and before you   *
 *                          can run this project there are a few hurdles you have to cross.                                         *
 *                                                                                                                                  *
 *                          1.  Unzip the .7z archive into your DAVE Workspace                                                      *
 *                          2.  Open the project from within DAVE                                                                   *
 *                          3.  Generate code, to recreate the deleted files : Menu -> DAVE -> Generate Code                        *
 *                          4.  Set your build configuration to Debug : Project explorer -> select this project ->                  *
 *                                                                      -> Right click for context menu -> Build Configuration ->   *
 *                                                                      -> Set active -> Debug                                      *
 *                          5.  Rebuild                                                                                             *
 *                          6.  Debug and run                                                                                       *
 *                                                                                                                                  *
 * How I work : 1.  6 X ANALOG_IO connected to pins 14.0/1/2 for VADC group 0 and 14.4/5/15.2 for VADC group 2                      *
 *              2.  2 X VADC groups, Group 0 and Group 2                                                                            *
 *                  Both set up with: Scan Request Source, with Autoscan selected to keep on scanning                               *
 *                                    3 Channels for each group, reading in order of Channel 2, 1, 0                                *
 *                                    Channel 2 result register is GxRES2 group result register, CH1 GxRES1, CH0 GxRES0, the 3      *
 *                                    channels you select must be consecutive channels, as the DMA requires continuous addresses    *
 *                                    GxRES0 for each group set to generate a result event                                          *
 *                                    Arbitration selected for Slot 1, Scan request source                                          *                                                                         *
 *              3.  2 X DMA channels                                                                                                *
 *                  Multiblock transfer with source and destination address reload, and Block size of 3                             *
 *                  Source and destination addresses increment, with a transfer width of 16bits, which is the size of the ADC result*
 *                  See below the definition of ADC_G0_results[3], ADC_G0_DMA_0_Destination_Address and ADC_G0_DMA_0_Source_Address *
 *              4.  IMPORTANT: DMA Source Gather, the VADC result in memory is a 32bit value, with the lower 16bits containing the  *
 *                  actual ADC result and the higher 16 bits containing the status of the result.  You are only interested in the   *
 *                  16bit result value, and not in the status value.  If you read the values as 16bit consecutive values your       *
 *                  result array[0] is going to contain the first adc[0] value, array[1] is going to contain the adc status of the  *
 *                  first adc[0] result, array[2] is going to contain the next adc[1] value. To cater for a situation like this you *
 *                  can transfer 32bit values, and mask the top 16bits out, or use the gather functionality with an interval of 1,  *
 *                  which will in effect read a 16 bit value, skip the next 16 bit value, read the next 16 bit value, skip the next *
 *                  16bit value - which is a VERY handy feature!                                                                    *
 *              5.  Each DMA channel is triggered on the VADC group's channel 0 result event                                        *
 *              6.  I have also added 2 Interrupts that are also triggered on each VADC channel 0 result event, I just toggle the   *
 *                  LEDs as an indication of activity on the VADC - THIS IS NOT NEEDED FOR THE VADC TO TRANSFER VIA DMA             *
 *              7.  On either of the button presses I output the result values to the terminal connected to the USB serial port,    *
 *                  my terminal of choice is TeraTerm                                                                               *
 *                                                                                                                                  *
 * Additional references : 1. AP32305 : Versatile Analog to Digital Converter (VADC)                                                *
 *                            https://www.infineon.com/dgdl/Infineon-VADC-XMC4000-AP32305-AN-v01_02-EN.pdf?fileId=5546d4624e765da5014ed98b2c043824
 *                            Particularly page 37, pin assignments for ADC group channels                                          *
 *                         2. AP32290 : General purpose Direct Memory Access (GPDMA)                                                *
 *                            https://www.infineon.com/dgdl/Infineon-GPDMA-XMC4000-AP32290-AN-v01_00-EN.pdf?fileId=5546d4624e765da5014ed9145c601e95
 *                            Page 10, Gather transfers explanation                                                                 *
 *                            Page 19 Figure 16, Gather transfer, specifically with VADC result registers                           *
 *                         3. XMC4500 Data Sheet                                                                                    *
 *                            https://www.infineon.com/dgdl/Infineon-XMC4500-DS-v01_05-EN.pdf?fileId=5546d46254e133b40154e1b56cbe0123
 *                            Particularly page 19-103 detailing the result registers                                               *
 *                                                                                                                                  *
 * Problems : while(!USBD_VCOM_IsEnumDone()); hangs if no usb is connected, problem specific to the Relax kit, where the power line *
 *            from the USB can come from 2 different inputs, and you cannot check if the plug is disconnected......                 *
 *                                                                                                                                  *
 * Todo : 1.  Additional dma channel to xfer the systick value so I can add a timestamp to an adc value                             *
 *        2.  Synchronous readings between VADC groups                                                                              *
 *                                                                                                                                  *
 * Copying, sharing and using : No limits whatsoever, please copy, use and share.                                                   *
 *                                                                                                                                  *
 * Why : I am publishing this in the hope that it will ease somebody's way out of the frustration of getting an ADC and DMA working *
 *       together in DAVE 4.4.2 as there are plenty samples, but no example that I could find that specifically uses the DAVE 4.4.2 *
 *       VADC and DMA APPS                                                                                                          *
 *                                                                                                                                  *
 * I would appreciate it plenty if you would bless me with a coffee/pizza/bucket full of Euros via Paypal, as I am willing to bet   *
 * that this is saving you at least 20 professional development hours where you don't have to battle to figure out the DMA and VADC *
 *                                                                                                                                  *
 * Kind regards from South Africa                                                                                                   *
 *                                                                                                                                  *
 * Gert van Biljon                                                                                                                  *
 *                                                                                                                                  *
 ***********************************************************************************************************************************/

/************************************************************************************************************************************
 $Author:: Gert_v_B                                                                                                                 $
 $Date:: 2019-06-09 12:16:45 +0200 (Sun, 09 Jun 2019)                                                                               $
 $Revision:: 1096                                                                                                                   $
 $URL:: https://techexplorer/svn/SVN_Repository/c/xmc4500_ADC_intro/main.c                                                          $
 ***********************************************************************************************************************************/

                            /*****************
                             *  2.10 *  2.01 *
                             * 14.08 *  2.14 *
                             * 14.09 *  2.15 *
        Rooi   - RA2 - G0CH0 * 14.00 * VAREF *
        Geel   - RB2 - G0CH2 * 14.02 * 14.01 * G0CH1 - RA5 - Oranje
        Groen  - RC0 - G2CH0 * 14.04 * 14.03 *
                             * 14.06 * 14.05 * G2CH1 - RE1 - Blou
                             * 14.12 * 14.07 *
                             * 14.14 * 14.13 *
        Pers   - RD2 - G2CH2 * 15.02 * 14.15 *
                             *  HIB0 * 15.03 *
                             *  3.00 *  HIB1 *
                             *  3.02 *  3.01 *
                             *  0.01 *  0.09 *
                             *  0.00 *  0.10 *
                             *  3.3V *  3.3V *
                             *****************

                             *****************
                             *  5.07 *  2.06 *
                             *  5.01 *  5.02 *
                    BUTTON2  *  1.15 *  5.00 *
                             *  1.13 *  1.14 * BUTTON1
                             *  1.11 *  1.12 *
                             *  1.05 *  1.10 *
                             *  1.03 *  1.04 *
         LED1 - VADC G0 ISR  *  1.01 *  1.02 *
         LED3 - VADC G2 ISR  *  1.09 *  1.00 * VADC G1 ISR - LED2
                             *  0.08 *  1.08 *
                             *  3.04 *  0.07 *
                             *  0.12 *  3.03 *
                             *  0.06 *  0.11 *
                             *  0.02 *  0.05 *
                             *  0.04 *  0.03 *
                             *   GND *   GND *
                             ****************/

#include <DAVE.h> //If the compiler cannot find this file, go and "generate code"
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <math.h>

/************************************************************************************************************************************
 * Global Variables, note the volatile modifier, used because a lot of these values are populated in Interrupt Service Routines     *
 *                                                                                                                                  *
 * Author : Gert van Biljon                                                                                                         *
 ***********************************************************************************************************************************/
volatile uint16_t ADC_G0_results[3];
volatile uint16_t ADC_G2_results[3];

volatile uint32_t *ADC_G0_DMA_0_Destination_Address = (uint32_t *) &ADC_G0_results[0];
volatile uint32_t *ADC_G0_DMA_0_Source_Address = (uint32_t *) &(VADC_G0->RES[0]);//should translate to 0x40004700

volatile uint32_t *ADC_G2_DMA_1_Destination_Address = (uint32_t *) &ADC_G2_results[0];
volatile uint32_t *ADC_G2_DMA_1_Source_Address = (uint32_t *) &(VADC_G2->RES[0]);

volatile char usb_serial_port_write_buffer[1000];

volatile uint16_t LED1_Toggle_Counter = 1;
volatile uint16_t LED2_Toggle_Counter = 1;

static void delay(uint32_t cycles);
void format_svn_and_compiler_stuff_into_string(void);
void format_6X_uint16_t_values_into_string(uint16_t value1, uint16_t value2, uint16_t value3, uint16_t value4, uint16_t value5, uint16_t value6);
void format_6X_uint16_t_values_into_plot_points_line(uint16_t value1, uint16_t value2, uint16_t value3, uint16_t value4, uint16_t value5, uint16_t value6);

/**

 * @brief main() - Application entry point
 *
 * <b>Details of function</b><br>
 * This routine is the application entry point. It is invoked by the device startup code. It is responsible for
 * invoking the APP initialization dispatcher routine - DAVE_Init() and hosting the place-holder for user application
 * code.
 */
int main(void)
{
    DAVE_STATUS_t status;

    status = DAVE_Init();/* Initialization of DAVE APPs  */

    if (status != DAVE_STATUS_SUCCESS)
    {
        /* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
        XMC_DEBUG("DAVE APPs initialization failed\n");

        while (1U)
        {
        }
    }

    memset((uint32_t *) ADC_G0_results, 0, 3 * sizeof( uint16_t ));
    memset((uint32_t *) ADC_G2_results, 0, 3 * sizeof( uint16_t ));

    DMA_CH_Enable(&DMA_CH_0);
    DMA_CH_Enable(&DMA_CH_1);

    XMC_VADC_GROUP_ScanTriggerConversion(VADC_G0);
    XMC_VADC_GROUP_ScanTriggerConversion(VADC_G2);

    if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
    {
        return -1;
    }

    while (!USBD_VCOM_IsEnumDone());

    delay(0xfffff);//Just give Windows/Terraterm some time to settle before I start printing USB stuff

    format_svn_and_compiler_stuff_into_string();
    USBD_VCOM_SendString((int8_t *) usb_serial_port_write_buffer);
    CDC_Device_USBTask(&USBD_VCOM_cdc_interface);

//  CDC_LineEncoding_t line_encoding_ptr;
//  USBD_VCOM_GetLineEncoding(&line_encoding_ptr);
//  snprintf((char *)usb_serial_port_write_buffer, sizeof(usb_serial_port_write_buffer), "Baud %lu \n\r", line_encoding_ptr.BaudRateBPS);
//  USBD_VCOM_SendString((int8_t *)usb_serial_port_write_buffer);
//  CDC_Device_USBTask(&USBD_VCOM_cdc_interface);

    while (1U)
    {
        if (DIGITAL_IO_GetInput(&BUTTON1_p1_14) == 0)
        {
        	format_6X_uint16_t_values_into_plot_points_line(ADC_G0_results[0], ADC_G0_results[1], ADC_G0_results[2], ADC_G2_results[0], ADC_G2_results[1], ADC_G2_results[2]);
            USBD_VCOM_SendString((int8_t *) usb_serial_port_write_buffer);
            CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
        }
        else if (DIGITAL_IO_GetInput(&BUTTON2_p1_15) == 0)
        {
        	format_6X_uint16_t_values_into_string(ADC_G0_results[0], ADC_G0_results[1], ADC_G0_results[2], ADC_G2_results[0], ADC_G2_results[1], ADC_G2_results[2]);
            USBD_VCOM_SendString((int8_t *) usb_serial_port_write_buffer);
            CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
        }
        else
        {

        }
    }
}

/************************************************************************************************************************************
 * Function name : VADC_G0_Result_Ready_IRQHandler                                                                                  *
 *                                                                                                                                  *
 * Author : Gert van Biljon                                                                                                         *
 *                                                                                                                                  *
 * What do I do : Interrupt handler that I call to toggle the LED on the result ready event of the VADC, not needed for the         *
 *                operation of the VADC or DMA, I just wanted some indication of what rate the ADC is sampling at.                  *
 *                                                                                                                                  *
 *                Me olde Fluke 79 series 2 multimeter of 1990 that I got for my 21st can only measure a max frequency of 100kHz,   *
 *                so I had to do some divide by 10 gymnastics to get a measurable result . . . . . . .                              *
 *                                                                                                                                  *
 *                Thus if I measure a frequency of 14kHz, this routine is actually hit 280 000times per second.                     *
 *                14kHz X 10 = 140kHz, but I am toggling the output, thus 140kHz X 2 = 280kHz                                       *
 ***********************************************************************************************************************************/
void VADC_G0_Result_Ready_IRQHandler (void)
{
    LED1_Toggle_Counter++;
    if (LED1_Toggle_Counter > 10)
    {
        LED1_Toggle_Counter = 1;
        DIGITAL_IO_ToggleOutput(&LED1_p1_1);
    }
}

void VADC_G2_Result_Ready_IRQHandler (void)
{
    LED2_Toggle_Counter++;
    if (LED2_Toggle_Counter > 10)
    {
        LED2_Toggle_Counter = 1;
        DIGITAL_IO_ToggleOutput(&LED2_p1_0);
    }
}

static void delay(uint32_t cycles)
{
    volatile uint32_t i;

    for (i = 0UL; i < cycles; ++i)
    {
        __NOP();
    }
}//delay from one of the Infineon help screens

/************************************************************************************************************************************
 * VT200 escape codes in TerraTerm/xterm                                                                                            *
 * http://www.johnrepici.com/serendipity/archives/192-The-xterm-256-color-table-set-colors-in-xterm-or-PuTTY.html                   *
 *                                                                                                                                  *
 * First encountered escape codes in Paul Somerson's excellent classic of 1989                                                      *
 * "PC Magazine DOS PowerTools: Techniques, Tricks and Utilities"                                                                   *
 *                                                                                                                                  *
 * To print in ORANGE coloured letters, send the following string "\033[38;5;208m"                                                  *
 *                                                                                                                                  *
 * \033[ : escape code                                                                                                              *
 * 38;   : foreground, use 48 for background                                                                                        *
 * 5;    : escape mode                                                                                                              *
 * 208   : colour to use : Orange, calculated as follows : 16 + (36 X Red = 5) + (6 X Green = 2) + (Blue = 0)                       *
 *         where Red Green and Blue ranges from 0 to 5                                                                              *
 * m     : end of escape code                                                                                                       *
 *                                                                                                                                  *
 * You can also specify 0-255 Red Green Blue values as follows ( escape mode 2 ) : \033[38;2;<r>;<g>;<b>m                           *
 * but this doesn't work with Putty terminal                                                                                        *
 *                                                                                                                                  *
 ***********************************************************************************************************************************/
#define print_WHITE      "\033[38;5;231m"
#define print_RED        "\033[38;5;196m"
#define print_ORANGE     "\033[38;5;208m"
#define print_YELLOW     "\033[38;5;226m"
#define print_GREEN      "\033[38;5;046m"
#define print_BLUE       "\033[38;5;014m"
#define print_VIOLET     "\033[38;5;213m"
#define print_LILAC      "\033[38;5;141m"
#define print_PURPLE     "\033[38;5;093m"
#define clrscr           "\033[2J"
#define cursor_move_home "\033[H" // can also do : "\033[12,23H" to move to row 12, column 23
//"\033[150C" Move cursor 150 positions right
//"\033[270D" Move cursor 270 positions left

/************************************************************************************************************************************
 * Function name : format_6X_uint16_t_values_into_plot_points_line                                                                  *
 *                                                                                                                                  *
 * Author : Gert van Biljon                                                                                                         *
 *                                                                                                                                  *
 * What do I do : I print a * character for each of the 6 uint16_t values that I receive                                            *
 *                The x position of the * character varies between 0 to 255, and is based on the value / 256                        *
 *                The x position of * character is set with the VT100 escape code "\033[nC", which moves the cursor n chars         *
 *                forward/right, and backwards/left with "\033[nD"                                                                  *
 ***********************************************************************************************************************************/
void format_6X_uint16_t_values_into_plot_points_line(uint16_t value1, uint16_t value2, uint16_t value3, uint16_t value4, uint16_t value5, uint16_t value6)
{
    snprintf(
               (char *)usb_serial_port_write_buffer,
               sizeof(usb_serial_port_write_buffer),
               print_RED
               "\033[%uC * \033[270D"
               print_ORANGE
               "\033[%uC * \033[270D"
               print_YELLOW
               "\033[%uC * \033[270D"
               print_GREEN
               "\033[%uC * \033[270D"
               print_BLUE
               "\033[%uC * \033[270D"
               print_LILAC
               "\033[%uC * \033[270D"
               "\n\r",
			   value1 >> 4,
			   value2 >> 4,
			   value3 >> 4,
			   value4 >> 4,
			   value5 >> 4,
			   value6 >> 4
            );
}//format_6X_uint16_t_values_into_plot_points_line

void format_6X_uint16_t_values_into_string(uint16_t value1, uint16_t value2, uint16_t value3, uint16_t value4, uint16_t value5, uint16_t value6)
{
    snprintf(
               (char *)usb_serial_port_write_buffer,
               sizeof(usb_serial_port_write_buffer),
               print_WHITE
               "*** "
               print_RED
               "Val1 : %5u"
               print_WHITE
               " * "
               print_ORANGE
               "Val2 : %5u"
               print_WHITE
               " * "
               print_YELLOW
               "Val3 : %5u"
               print_WHITE
               " * "
               print_GREEN
               "Val4 : %5u"
               print_WHITE
               " * "
               print_BLUE
               "Val5 : %5u"
               print_WHITE
               " * "
               print_LILAC
               "Val6 : %5u"
               print_WHITE
               " ***"
               "\n\r",
			   value1,
			   value2,
			   value3,
			   value4,
			   value5,
			   value6
             );
}//void format_6X_uint16_t_values_into_string(void)

void format_svn_and_compiler_stuff_into_string(void)
{
//TODO : add : memcpy(g_chipid, CHIPID_LOC, 16);

	char SVN_Author[] = "$Author: Gert_v_B $";
    char SVN_Revision[] = "$Revision: 1096 $";
    char SVN_Date[] = "$Date: 2019-06-09 12:16:45 +0200 (Sun, 09 Jun 2019) $";
    char SVN_String_Delimiter[] = " ";

    char * Extracted_SVN_Author_String;
    char * Extracted_SVN_Revision_String;
    char * Extracted_SVN_Date_String;
    char * Extracted_SVN_Time_String;

    Extracted_SVN_Author_String = strtok(SVN_Author, SVN_String_Delimiter);
    Extracted_SVN_Author_String = strtok(NULL, SVN_String_Delimiter);

    Extracted_SVN_Revision_String = strtok(SVN_Revision, SVN_String_Delimiter);
    Extracted_SVN_Revision_String = strtok(NULL, SVN_String_Delimiter);

    Extracted_SVN_Date_String = strtok(SVN_Date, SVN_String_Delimiter);
    Extracted_SVN_Date_String = strtok(NULL, SVN_String_Delimiter);
    Extracted_SVN_Time_String = strtok(NULL, SVN_String_Delimiter);

    snprintf(
               (char *)usb_serial_port_write_buffer,
               sizeof(usb_serial_port_write_buffer),
               clrscr
			   cursor_move_home
			   "\n\r"
			   "\n\r"
               print_WHITE
               "6 X VADC inputs sampler, transferring values to RAM with DMA\n\r"
               "Copyright (c) 2019 TechExplorer\n\r\n\r" //© is difficult to print on the different terminals thus I use (c)

               print_WHITE
               "Subversion Author : "
               print_RED
               "%s"
               "\r\n"

               print_WHITE
               "Subversion Revision : "
               print_ORANGE
               "%s"
               "\r\n"

               print_WHITE
               "Subversion Date : "
               print_YELLOW
               "%s"
               "\r\n"

               print_WHITE
               "Subversion Time : "
               print_GREEN
               "%s"
               "\r\n\r\n"

               print_WHITE
               "DAVE built Date : "
               print_BLUE
               "%s"
               "\r\n"

               print_WHITE
               "DAVE built Time : "
               print_VIOLET
               "%s"
               print_WHITE
               "\r\n",
               Extracted_SVN_Author_String,
               Extracted_SVN_Revision_String,
               Extracted_SVN_Date_String,
               Extracted_SVN_Time_String,
               __DATE__,
               __TIME__
            );
}//void format_svn_and_compiler_stuff_into_string(void)
